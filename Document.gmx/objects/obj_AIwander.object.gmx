<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprEWalkHK417</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-4</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Settings
energie = 2
//No animation please
image_speed = 0;

//Do I have a target?
id_target = -4;

//This is our path (if we have one)
p_path = -1;

//Current state
int_state = 0;

//What is my health?
int_health = 160;

//What is the direction of the bullet that hit us?
int_bulletDir = -5;

//Image index and image angle of the legs
int_legsImageAngle = 0;
int_legsImageIndex = 0;

//To move the AI along the path (manually)
int_pathPos = 0;

//The direction that I am currently looking while enroute on my path
int_lookThisWay = 0;

//What is my ammo?
int_ammo = 30;

//Am I aiming right now?
b_aim = false;

//This is important because we don't want perfect aim on the player, this throws it off a little bit
int_gunOffset = -5 + random(10);

//Am I crouching?
b_crouch = false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Countdown alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Countdown alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Countdown alarm
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///FSM

//Make sure the player exists before any of this
if (instance_exists(objPlayer)){

    //Analyze state of player
    switch(int_state){
        
        //What do to when I am created (move toward the center of the room)
        case 0:
        x += lengthdir_x(2, point_direction(x, y, room_width / 2, room_height / 2));
        y += lengthdir_y(2, point_direction(x, y, room_width / 2, room_height / 2));
        if (x &gt; 0//Find an open position and create a path to it once I am inside the room
        &amp;&amp; x &lt; room_width
        &amp;&amp; y &gt; 0
        &amp;&amp; y &lt; room_height){
            var xx, yy;
            do{
                xx = irandom(room_width);
                yy = irandom(room_height);
            }
            until(!place_meeting(xx, yy, _SOLID));
            p_path = scr_createPathTo(x, y, xx, yy, 32, 8, _SOLID, true);
            int_state = 1;
        }
        break;
    
        //Idle state
        case 1:
        int_pathPos += (1 - b_aim * .5) / path_get_length(p_path);//Move along the path manually
        x = path_get_x(p_path, int_pathPos);//Get the x position of the path at this point
        y = path_get_y(p_path, int_pathPos);
        if (int_pathPos &gt;= 1){
            var xx, yy;
            int_pathPos = 0;
            if (p_path &gt; -1){
                path_delete(p_path);
            }
            do{
                xx = irandom(room_width);
                yy = irandom(room_height);
            }
            until(!place_meeting(xx, yy, _SOLID));
            p_path = scr_createPathTo(x, y, xx, yy, 32, 8, _SOLID, true);
        }
        int_legsImageAngle = point_direction(xprevious, yprevious, x, y);//Make the legs image_angle the same direction as the path
        int_legsImageIndex += .4 - .25 * b_aim;//Make the legs slow if I am aiming, fast if I am not
        if (alarm[0] == -1){
            int_lookThisWay = point_direction(xprevious, yprevious, x, y) - 90 + random(180);//This is the direction that I am checking right now, switch this up every so often 
            b_aim = choose(true, false);//Am I aiming this way?
            path_speed = 3 - b_aim * .5;//Slow down on the path speed if I am aiming
            alarm[0] = room_speed * 2;//Reset the alarm here
        }
        image_angle += dsin(int_lookThisWay - image_angle) * 10;//Look this way (smoothly)
        if (b_aim){//If I am aiming, switch the sprite index to the player aiming
            sprite_index = sprEWalkHK417;
        }else{
            sprite_index = sprEWalkHK417;//Otherwise do the idle animation
            image_speed = 0;
        }
        if (point_in_triangle(objPlayer.x, objPlayer.y, x, y, x + lengthdir_x(500, image_angle - 30), y + lengthdir_y(500, image_angle - 30), x + lengthdir_x(500, image_angle + 30), y + lengthdir_y(500, image_angle + 30))
        &amp;&amp; !collision_line(x, y, objPlayer.x, objPlayer.y, objWall, false, true)){//Make sure the player is in my vision cone and a wall is not in the way
            var a, b, c, d, x0, y0, x1, y1;//End the path where I am standing (otherwise we if we just end the path we will start at the beginning of the path)
            //show_message("Last position: " + string(int_pathLastPos));
            image_speed = 0;//Important because we don't want to animate during a gun fight, we control the image_index manually during the next state
            image_index = 0;
            alarm[2] = 10;//This is a delay when we see the player. We can't start shooting the moment we see him (thats not realistic)
            pri_coverObj = ds_priority_create();//We are going to place all the id's of all the cover objects into a ds_priority, based on their distance to us. We are going to find cover away from the player to go to
            with(objWall){
                ds_priority_add(other.pri_coverObj, id, point_distance(x, y, other.x, other.y));//Add my identity to the AI's priority
            }
            a = false;//This is to break the outer loop
            for(b = 0;b &lt;= ds_priority_size(pri_coverObj) - 1;b ++){//We are going to find cover somewhere around the cover object
                c = ds_priority_find_min(pri_coverObj);
                for(d = 0;d &lt;= 3;d ++){
                    x1 = c.x + lengthdir_x(32, d * 90) + 16;
                    y1 = c.y + lengthdir_y(32, d * 90) + 16;
                    if (!position_meeting(x1, y1, objWall)//Make sure it is not touching a cover object
                    &amp;&amp; collision_line(x1, y1, objPlayer.x, objPlayer.y, objWall, false, true)//Does a line between this location and the player intersect cover?
                    &amp;&amp; !collision_line(x1, y1, objPlayer.x, objPlayer.y, objWall, false, true)){//Does a line between this location and the player not intersect a wall?
                        p_path = scr_createPathTo(x, y, x1, y1, 32, 8, _SOLID, true);//Create a path to this location and break the loop
                        int_pathPos = 0;
                        a = true;//So that we can break the outer loop
                        break;
                    }
                }
                if (a){//Break the outer loop as well
                    ds_priority_destroy(pri_coverObj);//Destroy prioriy to prevent a memory leak
                    break;
                }else{
                    ds_priority_delete_min(pri_coverObj);
                }
            }
            id_target = objPlayer;//This is our target (So that our vision will go red)
            int_state = 2;
        }
        break;
        
        //Shoot your gun
        case 2:
        sprite_index = sprEWalkHK417;//Set the sprite index to the correct aim shoot
        image_angle += dsin(point_direction(x, y, objPlayer.x, objPlayer.y) + int_gunOffset - image_angle) * 10;//Look toward player smoothly
        if (collision_line(x, y, objPlayer.x, objPlayer.y, objWall, false, true)){//Make sure the player is in my vision cone and a wall is not in the way
            var xx, yy;
            int_pathPos = 0;
            if (p_path &gt; -1){
                path_delete(p_path);//Delete it so there is no memory leak
            }
            do{
                xx = irandom(room_width);
                yy = irandom(room_height);
            }
            until(!place_meeting(xx, yy, _SOLID));
            b_crouch = false;//No more crouching
            id_target = -4;//So that our target thing goes green again
            p_path = scr_createPathTo(x, y, xx, yy, 32, 8, _SOLID, true);
            int_state = 1;
        }else{
            if (p_path &gt; -1){
                int_pathPos += 1 / path_get_length(p_path);
                x = path_get_x(p_path, int_pathPos);
                y = path_get_y(p_path, int_pathPos);
                int_legsImageAngle = point_direction(xprevious, yprevious, x, y);//Make the legs image_angle the same direction as the path
                int_legsImageIndex += .4 - .25 * b_aim;//Make the legs slow if I am aiming, fast if I am not
                if (int_pathPos &gt;= 1){
                    int_pathPos = 1;
                    path_delete(p_path);
                    p_path = -1;
                }
            }else{
                if (alarm[0] == -1){//Made it to the end of the path
                    b_crouch = choose(true, false);
                    alarm[0] = 30 + irandom(30);
                }
            }
            if (int_ammo &gt; 0){//Make sure I have ammo too
                if (alarm[1] == -1 &amp;&amp; alarm[2] == -1 &amp;&amp; !b_crouch){//Make sure I am not crouching when I fire (also make sure alarm[2] is -1) can't have him shooting the moment he sees the player
                    var xx, yy;
                    xx = x + lengthdir_x(35, image_angle - 5);
                    yy = y + lengthdir_y(35, image_angle - 5);
                    with(instance_create(xx, yy, objBullet)){
                        speed = 10;
                        direction = other.image_angle + -2.5 + random(5);
                        image_angle = direction;
                    }    
                    with(instance_create(x + lengthdir_x(5, image_angle), y + lengthdir_y(5, image_angle), objShell)){//Create cartridge
                        direction = other.image_angle - 90 - 45 + random(90);//Direction of cartridge
                        sprite_index = sprUziShell
                    }
                    int_ammo --;//Take some ammo away
                    int_gunOffset = -5 + random(10);//This is important because we don't want perfect aim on the player, this throws it off a little bit
                    alarm[1] = 6;//Reset alarm to shoot again
                }
                if (b_crouch){//If I am crouching, there is no recoil
                    image_index = 0;
                }else{//Otherwise...
                    if (alarm[1] mod 3 == 0){//If alarm[0] is a multiple of 3, switch the image_index from 0-1 or 0-1
                        image_index = 1 - image_index;
                    }
                }
            }else{
                int_state = 3;
            } 
        }
        break;
    
        //Reloading gun
        case 3:
        sprite_index = sprPReloadHK417;
        image_speed = .35;
        b_crouch = true;
        if (floor(image_index) == image_number - 1){
            int_ammo = 30;
            int_state = 2;
        }
        break;
    }
}
    
//Change the depth of the character based on if he is crouching or not
//depth = -100 + b_crouch * 100;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objBullet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///I got hit by a bullet

//Look the way the bullet came
int_lookThisWay = int_bulletDir + 180;

//Subtract health
int_health -= other.damage

scrBloodShot(x, y, 1)

//Destroy self if health is less than 0
if (int_health &lt;= 0){
    scrEnemyDieShot(objBullet)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw items

var a;
 
//Am I crouching?
if (b_crouch){
    //draw_sprite_ext(spr_playerBack, 0, x + lengthdir_x(-10, image_angle), y + lengthdir_y(-10, image_angle), 1, 1, image_angle, c_white, 1);
}else{
    //Draw legs shadow
    draw_sprite_ext(sprELegs, int_legsImageIndex, x + 4, y - 4, 1, 1, int_legsImageAngle, c_black, .4);
    //Draw legs
    draw_sprite_ext(sprELegs, int_legsImageIndex, x, y, 1, 1, int_legsImageAngle, c_white, 1);
}

//Draw torso shadow
draw_sprite_ext(sprite_index, image_index, x + 4, y - 4, 1, 1, image_angle, c_black, .4);

//Draw vision cone
if (id_target &gt; -4){
    a = c_red;
}else{
    a = c_green;
}
draw_set_alpha(.5);
draw_triangle_colour(x, y, x + lengthdir_x(500, image_angle - 30), y + lengthdir_y(500, image_angle - 30), x + lengthdir_x(500, image_angle + 30), y + lengthdir_y(500, image_angle + 30), a, a, a, false); 
draw_set_alpha(1);

//Draw self
draw_self();

//Draw muzzleflash (make sure I am in the attack state, that the recoil has happened, that the delay has gone off, and that I am not crouching
if (int_state == 2
&amp;&amp; alarm[0] mod 5 == 0 
&amp;&amp; alarm[2] == -1 
&amp;&amp; !b_crouch){
    var a = choose(true, true, false);
    if (a){
        var xx, yy;
        xx = x + lengthdir_x(35, image_angle - 5);
        yy = y + lengthdir_y(35, image_angle - 5);
        draw_sprite_ext(sprMuzzleFlash, 1, xx, yy, 1 + random(1), random(3), image_angle, c_white, 1);
    }
}

//draw_text(x, y - 50, string(int_state));
//if (p_path &gt; -1){
//    draw_path(p_path, x, y, true);
//}
//draw_sprite(spr_playerBack, 0, int_pathX, int_pathY);
//draw_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
